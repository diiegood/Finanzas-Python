"""
Portafolio Optimo con Python
"""

import csv
import numpy as np
import pandas as pd
from IPython.display import display

#librerias para graficar
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick

#para checar los factores
from factor_analyzer.factor_analyzer  import calculate_bartlett_sphericity
from factor_analyzer.factor_analyzer import calculate_kmo

#modulo para resolver problemas de optimizacion y regresion lineal
from scipy.optimize import minimize #para resolver la optimizacion
from sklearn.linear_model import LinearRegression


#Ejercicio 1 Obtener una matriz de 12 activos con sus rendimientos logaritmicos, 
# con un intervalo de periodo de 2021 a 2025.

import yfinance as yf

#securities:
tickers = [
    "NVDA",    # Nvidia
    "SOXL",   # Bull 3X microchips
    "SLV",   # Silver ETF
    "IAU",   # Gold ETF
    "NAFTRAC.MX",  # IPC-BMV ETF
    "SPY",   # SP500 ETF
    "INTC",   # Intel Corporation
    "SOFI",   # SoFi Tecnologies, Inc.
    "PFE",    # Pfizer Inc
    "PYPL",    # Paypal Holdings Inc.
    "TSLA",     #Tesla Inc.
    "SAN",    #Banco Santander, S.A.
]


start_date = "2021-01-01" #iniicio de la fecha de analisis
end_date = "2025-12-31"  #fin del periodo de analisis

#descarga de datos de yahoo finance
data = yf.download(
    tickers=tickers,  #descargar la lista creada de tickers
    start=start_date, #descargar desde el inicio de la fecha
    end=end_date,    #hasta el final de la fecha 
    interval="1d",  #intervalo de frecuencia de datos 1 dia
    auto_adjust=False, 
    group_by="ticker",
    threads=True
)

#obtencion de precios de cierre
close_prices = pd.DataFrame()   #crear un data frame vacio para los cierres de precio

available_tickers = data.columns.levels[0]  #indexar los ticekers disponibles

#se llena el data frame vacio anteriormente creado con los datos de cierre de precio de los tickers
for ticker in tickers: 
    if ticker in available_tickers:
        close_prices[ticker] = data[ticker]["Close"] 


# Mantener días con información suficiente
close_prices = close_prices.dropna(thresh=5) #elimina filas que tengan menos de 5 valores no nulos
close_prices.index.name = "Fecha"

retornos_logaritmicos = np.log(close_prices / close_prices.shift(1)).dropna() #calculo de retornos logaritmicos
cumulative_returns = np.exp(retornos_logaritmicos.cumsum()) #retornos acumulados


#data frame de los rendimientos logaritmicos
retornos_logaritmicos.info()
retornos_logaritmicos.describe()
retornos_logaritmicos.head(50)
retornos_logaritmicos.tail(50)

#conversion del dataframe index a tipo hora fecha de datetimeindex de pandas
retornos_logaritmicos.index = pd.to_datetime(retornos_logaritmicos.index)

"""
utilidades del pd.to_datetime

#1 filtrar por fechas:
retornos_logaritmicos["2024-01-01":"2025-12-31"]  #este codigo filtra los rendimientos en un intervalo de tiempo

#2 agrupar la frecuencia de datos bajo cierto periodo:
retornos_logaritmicos.resample("Y").mean()   #agrupa por año los rendimientos  (cambiar "Y" por M,Q, 2Q, A)
retornos_logaritmicos.groupby(retornos_logaritmicos.index.year).std()  #muestra la desviacion estandar

#3 Grafica los datos 
plt.plot(retornos_logaritmicos.index, retornos_logaritmicos["SPY"])  #grafica los datos correspondientes a SPY

#4 Calcula estadisaticas temporales
retornos_logaritmicos.index.year
retornos_logaritmicos.index.month

"""

display(retornos_logaritmicos) #convierte el dataframe en una tabla interactiva

retornos_logaritmicos

#Propiedades del dataframe
print("Hay un total de", len(retornos_logaritmicos.columns), "activos incluidos dentro de esta matriz")
print("las acciones incluidas en este dataframe son:")
for name in retornos_logaritmicos.columns: print(name)

display(retornos_logaritmicos.describe().T) #breve resumen estadistico de los datos del data frame



#Ejercicio 2 Graficar los rendimientos diarios y los retornos contra los datos 3:45


