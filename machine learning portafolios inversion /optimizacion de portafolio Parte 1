"""
Portafolio Optimo con Python
"""

import csv
import numpy as np
import pandas as pd
from IPython.display import display

#librerias para graficar
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick

#para checar los factores
from factor_analyzer.factor_analyzer  import calculate_bartlett_sphericity
from factor_analyzer.factor_analyzer import calculate_kmo

#modulo para resolver problemas de optimizacion y regresion lineal
from scipy.optimize import minimize #para resolver la optimizacion
from sklearn.linear_model import LinearRegression


#Ejercicio 1 Obtener una matriz de 12 activos con sus rendimientos logaritmicos, 
# con un intervalo de periodo de 2021 a 2025.

import yfinance as yf

#securities:
tickers = [
    "NVDA",    # Nvidia
    "SOXL",   # Bull 3X microchips
    "SLV",   # Silver ETF
    "IAU",   # Gold ETF
    "NAFTRAC.MX",  # IPC-BMV ETF
    "SPY",   # SP500 ETF
    "INTC",   # Intel Corporation
    "SOFI",   # SoFi Tecnologies, Inc.
    "PFE",    # Pfizer Inc
    "PYPL",    # Paypal Holdings Inc.
    "TSLA",     #Tesla Inc.
    "SAN",    #Banco Santander, S.A.
]


start_date = "2021-01-01" #iniicio de la fecha de analisis
end_date = "2026-02-03"  #fin del periodo de analisis

#descarga de datos de yahoo finance
data = yf.download(
    tickers=tickers,  #descargar la lista creada de tickers
    start=start_date, #descargar desde el inicio de la fecha
    end=end_date,    #hasta el final de la fecha 
    interval="1d",  #intervalo de frecuencia de datos 1 dia
    auto_adjust=False, 
    group_by="ticker",
    threads=True
)

#obtencion de precios de cierre
close_prices = pd.DataFrame()   #crear un data frame vacio para los cierres de precio

available_tickers = data.columns.levels[0]  #indexar los ticekers disponibles

#se llena el data frame vacio anteriormente creado con los datos de cierre de precio de los tickers
for ticker in tickers: 
    if ticker in available_tickers:
        close_prices[ticker] = data[ticker]["Close"] 


# Mantener días con información suficiente
close_prices = close_prices.dropna(thresh=5) #elimina filas que tengan menos de 5 valores no nulos
close_prices.index.name = "Fecha"

retornos_logaritmicos = np.log(close_prices / close_prices.shift(1)).dropna() #calculo de retornos logaritmicos
cumulative_returns = np.exp(retornos_logaritmicos.cumsum()) #retornos acumulados


#data frame de los rendimientos logaritmicos
retornos_logaritmicos.info()
retornos_logaritmicos.describe()
retornos_logaritmicos.head(50)
retornos_logaritmicos.tail(50)

#conversion del dataframe index a tipo hora fecha de datetimeindex de pandas
retornos_logaritmicos.index = pd.to_datetime(retornos_logaritmicos.index)

"""
utilidades del pd.to_datetime

#1 filtrar por fechas:
retornos_logaritmicos["2024-01-01":"2025-12-31"]  #este codigo filtra los rendimientos en un intervalo de tiempo

#2 agrupar la frecuencia de datos bajo cierto periodo:
retornos_logaritmicos.resample("Y").mean()   #agrupa por año los rendimientos  (cambiar "Y" por M,Q, 2Q, A)
retornos_logaritmicos.groupby(retornos_logaritmicos.index.year).std()  #muestra la desviacion estandar

#3 Grafica los datos 
plt.plot(retornos_logaritmicos.index, retornos_logaritmicos["SPY"])  #grafica los datos correspondientes a SPY

#4 Calcula estadisaticas temporales
retornos_logaritmicos.index.year
retornos_logaritmicos.index.month

"""

display(retornos_logaritmicos) #convierte el dataframe en una tabla interactiva

retornos_logaritmicos

#Propiedades del dataframe
print("Hay un total de", len(retornos_logaritmicos.columns), "activos incluidos dentro de esta matriz")
print("las acciones incluidas en este dataframe son:")
for name in retornos_logaritmicos.columns: print(name)

display(retornos_logaritmicos.describe().T) #breve resumen estadistico de los datos del data frame



#Ejercicio 2 Graficar los rendimientos diarios 

n = len(retornos_logaritmicos.columns)
col = 4 #especificar el numero de columnas para la grafica
row = int(np.ceil(n/col)) #especifica el numero de columnas
fig_hei = row * 3 #plot height
fig_wid = col * 4 #especifica el width

ax = retornos_logaritmicos.plot(subplots=True, layout=(row, col), figsize=(fig_wid, fig_hei),
                           sharey= True, sharex = True, #comparte el eje x, y en las sbgraficas
                           title = "Rendimientos diarios de las acciones vs fechas")


for i in range(col):
    ax[0,i].xaxis.set_tick_params(which="both", top=True, labeltop= True, labelrotation=40)
    
    
fig = ax[0,0].get_figure()
fig.tight_layout()
fig.subplots_adjust(top=0.93) #para ajustar indirectamente la locacion del titulo
plt.show()

#limpiar datos de la matriz de rendimientos
retornos = retornos_logaritmicos.drop("SOFI", axis=1) #se le quita los rendimientos de SOFI al data frme
retornos = retornos_logaritmicos.dropna() #se le quitan los na
display(retornos)

#Convertir los rendimientos diarios en semanales
retornos_semanales = (retornos_logaritmicos+1).resample("W").prod() -1
#remueve manualmente los retornso de los datos de la primera semana
retornos_semanales = retornos_semanales.drop(retornos_semanales.index[[0]]) 
#remueve manualmente los retornso de los datos de la ultima semana
retornos_semanales = retornos_semanales.drop(retornos_semanales.index[[-1]])
display(retornos_semanales)


#Extraer los datos de un activo en concreto
plata = retornos_semanales[["SLV"]]
display(plata)

#Excluir datos de la plata dentro del dataframe 
retornos_semanales_sinplata = retornos_semanales.drop("SLV", axis = 1)

#Ejercicio 3 Descargar los datos de los treasury de la FRED con la fecha igual a los de los activos
8:03-9:19

