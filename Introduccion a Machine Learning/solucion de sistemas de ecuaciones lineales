import ipywidgets as widgets
from ipywidgets import interact, Dropdown
import numpy as np

question1 = "\033[1mSelect one of the options given:"
solution1 = {'A':'\033[91mNot quite. While both functions are used to create empty arrays, np.zeros() is initialized with the value 0.',
'B':"\033[91mNot quite. np.zeros() is inialized, and it gives an output of 0's.",
'C':"\033[91mNot quite. Most often, np.empty() is faster since it is not initialized.",
'D':''' \033[92mTrue! np.empty() creates an array with uninitialized elements from available memory space and may be faster to execute.'''}



def mcq(question, solution):
    s = ''
#     print(question)
    print("\033[1mPlease select the correct option:")
    answer_w = Dropdown(options = solution.keys(), value=None, layout=widgets.Layout(width='25%'))

    @interact(Answer = answer_w)
    def print_city(Answer):
        if(Answer != None):
            s = solution[Answer]
#             print("\n")
            print(s)
            
 
###############################################################################
###############################################################################

"Solucion de sistemas lineales de ecuaciones de 3 variables con matrices y algebra"

A = np.array([
        [4, -3, 1],
        [2, 1, 3],
        [-1, 2, -5]
    ], dtype=np.dtype(float))

b = np.array([-10, 0, 17], dtype=np.dtype(float))

print("Matrix A:")
print(A)
print("\nArray b:")
print(b)

print(f"Shape of A: {np.shape(A)}")
print(f"Shape of b: {np.shape(b)}")

x = np.linalg.solve(A, b)

print(f"Solution: {x}")


d = np.linalg.det(A)

print(f"Determinant of matrix A: {d:.2f}")

A_system = np.hstack((A, b.reshape((3, 1))))

print(A_system)


# exchange row_num of the matrix M with its multiple by row_num_multiple
# Note: for simplicity, you can drop check if  row_num_multiple has non-zero value, which makes the operation valid
def MultiplyRow(M, row_num, row_num_multiple):
    # .copy() function is required here to keep the original matrix without any changes
    M_new = M.copy()
    M_new[row_num] = M_new[row_num] * row_num_multiple
    return M_new

print("Original matrix:")
print(A_system)
print("\nMatrix after its third row is multiplied by 2:")
# remember that indexing in Python starts from 0, thus index 2 will correspond to the third row
print(MultiplyRow(A_system,2,2))


# multiply row_num_1 by row_num_1_multiple and add it to the row_num_2, 
# exchanging row_num_2 of the matrix M in the result
def AddRows(M, row_num_1, row_num_2, row_num_1_multiple):
    M_new = M.copy()
    M_new[row_num_2] = row_num_1_multiple * M_new[row_num_1] + M_new[row_num_2]
    return M_new

print("Original matrix:")
print(A_system)
print("\nMatrix after exchange of the third row with the sum of itself and second row multiplied by 1/2:")
print(AddRows(A_system,1,2,1/2))


# exchange row_num_1 and row_num_2 of the matrix M
def SwapRows(M, row_num_1, row_num_2):
    M_new = M.copy()
    M_new[[row_num_1, row_num_2]] = M_new[[row_num_2, row_num_1]]
    return M_new

print("Original matrix:")
print(A_system)
print("\nMatrix after exchange its first and third rows:")
print(SwapRows(A_system,0,2))


A_ref = SwapRows(A_system,0,2)
# Note: ref is an abbreviation of the row echelon form (row reduced form)
print(A_ref)


# multiply row 0 of the new matrix A_ref by 2 and add it to the row 1
A_ref = AddRows(A_ref,0,1,2)
print(A_ref)


# multiply row 0 of the new matrix A_ref by 4 and add it to the row 2
A_ref = AddRows(A_ref,0,2,4)
print(A_ref)


# multiply row 1 of the new matrix A_ref by -1 and add it to the row 2
A_ref = AddRows(A_ref,1,2,-1)
print(A_ref)

# multiply row 2 of the new matrix A_ref by -1/12
A_ref = MultiplyRow(A_ref,2,-1/12)
print(A_ref)


x_3 = -2
x_2 = (A_ref[1,3] - A_ref[1,2] * x_3) / A_ref[1,1]
x_1 = (A_ref[0,3] - A_ref[0,2] * x_3 - A_ref[0,1] * x_2) / A_ref[0,0]

print(x_1, x_2, x_3)


A_2= np.array([
        [1, 1, 1],
        [0, 1, -3],
        [2, 1, 5]
    ], dtype=np.dtype(float))

b_2 = np.array([2, 1, 0], dtype=np.dtype(float))

d_2 = np.linalg.det(A_2)

print(f"Determinant of matrix A_2: {d_2:.2f}")


# x_2 = np.linalg.solve(A_2, b_2)
A_2_system = np.hstack((A_2, b_2.reshape((3, 1))))
print(A_2_system)


# multiply row 0 by -2 and add it to the row 1
A_2_ref = AddRows(A_2_system,0,2,-2)
print(A_2_ref)


# add row 1 of the new matrix A_2_ref to the row 2
A_2_ref = AddRows(A_2_ref,1,2,1)
print(A_2_ref)


b_3 = np.array([2, 1, 3])

A_3_system = np.hstack((A_2, b_3.reshape((3, 1))))
print(A_3_system)


# multiply row 0 of the new matrix A_3_system by -2 and add it to the row 2
A_3_ref = AddRows(A_3_system,0,2,-2)
print(A_3_ref)


# add row 1 of the new matrix A_3_ref to the row 2
A_3_ref = AddRows(A_3_ref,1,2,1)
print(A_3_ref)


