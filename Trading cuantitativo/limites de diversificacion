import funciones_curso as fc
import pandas as pd
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt
from scipy.optimize import minimize

"Practica 7 Limites de la Diversificacion"

datos = fc.rendimientos_industria()
er = fc.rendimientos_anualizados(datos["1996":"2000"], 12)
cov = datos["1996":"2000"].cov()

"""
Analizar que suceden ante las caidas del mercado
en relacion a las correlaciones entre las acciones del mercado
Calcular la capitalizacion bursatil de las empresas que cotizan en bolsa 
por fraccion y total.

"""
#creacion de un indice bursatil ponderado por capitalizacion de mercado 



ind_return = fc.rendimientos_industria()
ind_nfirms = fc.get_ind_nfirms()
ind_size = fc.get_ind_size()

ind_return.shape

#capitalizacion de mercado de la industria
ind_market_Cap = ind_nfirms * ind_size
ind_market_Cap.shape

#se quieren sumar todas las columnas
total_market_cap =  ind_market_Cap.sum(axis="columns")
total_market_cap.plot()

capitalizacion_pesos_industria = ind_market_Cap.divide(total_market_cap, axis="rows")
capitalizacion_pesos_industria.plot()
 
capitalizacion_pesos_industria.head()
 
capitalizacion_pesos_industria["1926":].sum(axis = "columns") 

capitalizacion_pesos_industria[["Fin", "Steel"]].plot(figsize=(12,6))

rendimiento_total_mercado = (capitalizacion_pesos_industria * ind_return).sum(axis ="columns")
rendimiento_total_mercado.plot() 


rendimiento_total_mercado = fc.obtener_retornos_totales()
rendimiento_total_mercado_index = fc.drawdown(rendimiento_total_mercado).Wealth
rendimiento_total_mercado_index.plot(figsize=(12,6), title= 'rendimientos totales mercado')
 
rendimiento_total_mercado_index["1980":].plot(figsize=(12,6))

#se traza el indice y la media movil a 36 meses
rendimiento_total_mercado_index["1980":].rolling(window=36).mean().plot() 
#rolling funciona cuando se indexa una serie de tiempo / a 36 meses

#el primer punto de datos requiere 36 meses, donde se pierden 36 meses de datos para generar la media movil
#porque se requiere ese tiempo para poder calcular la media movil, donde el primer valor de la media movil
#estara despues de esos 36 meses.


tmi_tr3mrets = rendimiento_total_mercado.rolling(window= 36 ).aggregate(fc.rendimientos_anualizados, 
                                                                        periodos_año = 12)

tmi_tr3mrets .plot(figsize = (12,6), legend = True, label = "Rendimiento con 36 meses")

rendimiento_total_mercado.plot(label = "Returns", color = "red", legend  =True)


"Para graficar las dos graficas en uno solo correr ambos codigos al mismo tiempo"
"si se quiere una grafica por variable correr uno por separado del otro"

###############################################################################

"Correlaciones de balanceo con varios indices agrupado "

#serie de tiempo de correlaciones
"Multi-index"
#sirve para poner un doble indice con empresa y año (hay dos columnas en la parte de los indices)
#cuando no es multi-indice solo tiene una columna en este caso indexada (año)

"Matriz con doble indice (multi-indice)"
#rolling es para agrupar todas las filas en una ventana, dada o intervalo
ts_corr = ind_return.rolling(window= 36).corr()
ts_corr.tail() #es una serie de tiempo de una matriz donde tiene doble indice (multi-indice)
ts_corr.plot()

ind_return.head() #matriz con un solo indice


#se quiere medir la correlacion media de toda la matriz durante un año dado
#por lo que se debe agrupar , al ser un multi-indice se debe indicar bajo que nivel o indice

ts_corr.index.names = ["date", "industry"]
ts_corr.tail()

#se calcula una correlacion sobre 36 meses
#se agrupa por fecha
#se agrupa por un nivel a la derecha

ind_tr36corr = ts_corr.groupby(level = "date").apply(lambda cormat:cormat.values.mean())
ind_tr36corr.plot()

tmi_tr3mrets.plot(label = "rendimientos 36 meses", figsize=(12,6), legend=True, secondary_y = True, color = "red")
ind_tr36corr.plot(label = "correlaciones 36 meses", legend = True, color= "green")

"""
Se puede ver que los rendimientos son los de la grafica roja y las correlaciones la verde 

eje de la derecha es de los rendimientos en porcentaje

eje de la izquierda es de las correlaciones en porcentaje

Las linea verde es la correlacion media entre industrias 
"""

""" ############################# Explicacion: 
Cuando el mercado se hunde se puede ver que las correlaciones suben  y cuando
el mercado sube las correlaciones vuelven a la normalidad, teniendo en cuenta las correlaciones de 
36 meses, por lo que esta imagen nos puede decir visualmente
como la diversificacion falla cuando se necesita

Esto porque cuando el mercado esta cayendo muy fuerte se busca las correlaciones 
para poder salir de el con una contraposicion que contrarreste el efecto
pero las correlaciones empiezan a subir 

"""

#Analisis del periodo de 2008

tmi_tr3mrets["2007":].plot(label = "rendimientos 36 meses", figsize=(12,6), legend=True, secondary_y = True, color = "red")
ind_tr36corr["2007":].plot(label = "correlaciones 36 meses", legend = True, color= "green")


"""
Conforme el mercado se desploma en 2008, las correlaciones se disparan de forma estrepitosa
llegando a un maximo de 0.75 de correlacion donde la diversificacion no ayuda
porque se saca de un promedio total de todas las correlaciones de los sectores por lo
que todos tenian un 75% de correlacion osea ninguno o estadisticamente ninguno durante
este experimento se podia demostrar que sirviera para amortiguar el golpe ya que iban 
incrementando en vez de bajar
"""

correlacion_entre_rendimientos_y_correlaciones = tmi_tr3mrets.corr(ind_tr36corr)
correlacion_entre_rendimientos_y_correlaciones


#en conclusion la diversificacion no ayuda cuando los mercados se caen porque
#la mayoria de los sectores aumenta su correlacion por lo que le pasa el mismo efecto
#suponiendo que se calcula una media de 36 meses o 3 años 
#la correlacion deberia bajar para que funcionara la diversificacion general

"Temas vistos"
#ventanas moviles = medias moviles 
#multi-indices


##############################################################################
##############################################################################
##############################################################################

"Practica 8 CPPI"

import funciones_curso as fc
import pandas as pd
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

ind_return = fc.rendimientos_industria()
tmi_return = rendimiento_total_mercado_index

risky_r = ind_return["2000":][["Steel", "Fin", "Beer"]]
risky_r.shape

safe_r = pd.DataFrame().reindex_like(risky_r)
safe_r.shape

#para programar el algoritmo CPPI
safe_r[:]= 0.03 / 12  #datos mensuales se divide entre 12 , 
start = 1000  #cantidad en dolares
floor = 0.8 #liminite minimo de operacion / floor  80% del valor incial

#calcular el presupuesto de riesgo 
#cushion -( Asset Value minus Floor Value ) 
#compute an allocation to safe and risky assets  / m * (risk budget)
#recalcular el valor del activo basado en los rendimientos

def compound(r):
    return (1+r).prod()-1
    
def compound2(r):
    return np.expm1(np.log1p(r).sum())


compound(risky_r) #se obtiene el resultadod de multiplciarlos todos 
compound2(risky_r)

compound(ind_return[["Steel", "Fin", "Beer"]])

compound2(ind_return[["Steel", "Fin", "Beer"]])

"Calculo de CPPI"

dates = risky_r.index
n_steps = len(dates)
account_value = start
floor_value = start * floor
m = 3


account_history = pd.DataFrame().reindex_like(risky_r)
cushion_history = pd.DataFrame().reindex_like(risky_r)
risky_w_history = pd.DataFrame().reindex_like(risky_r)

#corregir las funciones

for step in range(n_steps):
    cushion = (account_value - floor_value)/account_value #diferencia absoluta valor restante
    # ratio se expresa en porcentaje , diferencia entre cuenta y el limite del piso de caida
    "El riesgo no debe ir arriba del 100% ni debajo del 0%"
    risky_w = m * cushion #peso del activo de riesgo en la cartera 
    risky_w = np.minimum(risky_w,1)
    risky_w = np.maximum(risky_w,0)
    safe_w = 1 - risky_w #peso del activo sin riesgo en la cartera
    risky_alloc = account_value*risky_w
    safe_alloc = account_value*safe_w
    
    #actualizar el valor de la cuenta por el valor del tiempo
    account_value = risky_alloc*(1+risky_r.iloc[step]) + safe_alloc*(1+safe_r.iloc[step])
    #guardar los valores donde se pueda ver el historial y la grafica
    cushion_history.iloc[step] = cushion
    risky_w_history.iloc[step] = risky_w
    account_history.iloc[step] = account_value
    risky_wealth = start*(1+risky_r).cumprod()
    

"""
cushion es la amortiguacion o la cantidad que puede perderse antes de entrar en el
limite de riesgo por lo que esta seria la diferencia de la cantidad total de la cartera
menos el limite del piso, si la cartera es de 1000 y el piso empieza en 600 , que es un 60%
el colchon serian 400 que seria el rango que empieza en el total hasta donde empieza el limite
de perdida , seria  1000-600 = 400 de colchon antes de entrar en el limite de perdida, 
representando el colchon un 40% de la cartera

si se usa un m o multiplicador de 3 se multiplica por el porcentaje del colchon, siendo
3 (.4) = 1.20 osea 120% ya que la formula es  m*(total - piso)  /  colchon = total - piso
por lo que la asignacion del activo de riesgo es de 120%, el peso de riesgo no debe ser 
mayor de 100% 
"""

#Grafica general de las industrias de la cartera
account_history.head()
risky_wealth = start*(1+ risky_r).cumprod()
account_history["Beer"].plot()
risky_wealth.plot()

#grafica de comparacion de cartera con solo cerveza y cartera con cerveza y activo sin riesgo
ax = account_history["Beer"].plot(figsize=(12,6))
risky_wealth["Beer"].plot(ax = ax, style = "k:") #el estilo es de negro con lineas punteadas
ax.axhline(y = floor_value, color = "r",  linestyle = "--")

#linea azul es la serie principal trazada  portafolio diversificado con cerveza y libre de riesgo
#la linea negra punteaad es el risky_wealth osea cartera con pura industria cervecera
#la linea roja es la linea punteada / limite fijado absoluto 


#grafica activos
risky_w_history.plot()


#las probabilidades de tocar el piso dependen de lo grande que sea el colchon
#entre mas grande es mejor porque son menores las probabildiades de tocar el piso
#el drawdown actualiza la caida del piso porque se basa en los maximos que se van alcanzando
#mientras que aqui la caida es fija porque solo se basa en la cuenta que se tiene de limite de caida
#ademas del limite del porcentaje del colchon que se maneje

#grafica de comparacion de cartera con solo cerveza y cartera con industria financiera y activo sin riesgo

ind = "Fin"
ax = account_history[ind].plot(figsize=(12,6))
risky_wealth[ind].plot(ax = ax, style = "k:") #el estilo es de negro con lineas punteadas
ax.axhline(y = floor_value, color = "r",  linestyle = "--")

#linea azul es la serie principal trazada / cartera diversificada con activo sin riesgo
#la linea negra punteaad es el si se hubiera invertido solo en finanzas
#la linea roja es la linea punteada / limite fijado absoluto 

#ahora lo mismo pero con al industria del acero
#grafica reprensenta los rendimientos obtenidos al invertir 100 usd por activo
ind = "Steel"
ax = account_history[ind].plot(figsize=(12,6))
risky_wealth[ind].plot(ax = ax, style = "k:") #el estilo es de negro con lineas punteadas
ax.axhline(y = floor_value, color = "r",  linestyle = "--")


"Funcion que muestra las estadisticas de cada activo calculando los parametros de interes"
fc.summary_stats(risky_r)

btr = fc.run_cppi(risky_r) #back test results
#se toman los resultados de las pruebas restrospectivas y se convierten en retornos

#calcula los rendimientos de la funcion de btr / ademas remueve el NaN de la primera celda
stats_cartera = fc.summary_stats(btr["Wealth"].pct_change().dropna()) #cambio de porcentaje de cotizacion diaria son los rendimientos
stats_cartera

#corregir desde las funciones.
btr = fc.run_cppi(tmi_return["2007":])
ax = btr["Wealth"].plot(figsize=(12,6), legend = False)
btr["Risky Wealth"].plot(ax= ax, style = "k--", legend = False)


fc.summary_stats(btr["Risky Wealth"].pct_change().dropna())
fc.summary_stats(btr["Wealth"].pct_change().dropna())


#todos los portafolios empiezan desde 1000 dolares de inversion pero cada
#sector termina con una cantidad diferente conforme a su rendimiento
btr = fc.run_cppi(ind_return["2007":][["Steel","Fin","Beer"]], drawdown=0.25)
ax = btr["Wealth"].plot(figsize=(12,6))
btr["Risky Wealth"].plot(ax = ax, style="--")

#stats de diferentes portafolios de una cartera con activos de puro riesgo
#y otra con una cartera diversificada
fc.summary_stats(btr["Risky Wealth"].pct_change().dropna())
fc.summary_stats(btr["Wealth"].pct_change().dropna())


